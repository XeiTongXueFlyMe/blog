<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on roc</title>
    <link>http://imroc.io/tags/docker/</link>
    <description>Recent content in Docker on roc</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>roc@imroc.io (roc)</managingEditor>
    <webMaster>roc@imroc.io (roc)</webMaster>
    <lastBuildDate>Wed, 06 Sep 2017 16:35:18 +0800</lastBuildDate>
    
	<atom:link href="http://imroc.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Docker中CMD与ENTRYPOINT的简明理解</title>
      <link>http://imroc.io/post/docker/understand-docker-cmd-entrypoint/</link>
      <pubDate>Wed, 06 Sep 2017 16:35:18 +0800</pubDate>
      <author>roc@imroc.io (roc)</author>
      <guid>http://imroc.io/post/docker/understand-docker-cmd-entrypoint/</guid>
      <description>CMD提供容器启动的默认行为，运行不指定运行的命令及参数，会默认执行CMD中的。
例如hello镜像的Dockerfile中有 CMD [&amp;quot;echo&amp;quot;,&amp;quot;&#39;hello world&#39;&amp;quot;]
 执行 docker run hello，输出hello world 执行 docker run hello /bin/sh -c &amp;quot;shit&amp;quot; 则会覆盖CMD中所有的东西，输出shit  ENTRYPOINT让容器可以当成一个普通的可执行命令一样使用。
例如echo镜像的Dockerfile中有ENTRYPOINT [&amp;quot;/bin/echo&amp;quot;]
 执行docker run echo &amp;quot;hello world&amp;quot;，输出hello world  若同时CMD也存在，比如: CMD [&amp;quot;&#39;hello world&#39;&amp;quot;] ，那么CMD中的值就是ENTRYPOINT的默认参数。
 执行 docker run echo， 即不加参数，也会输出hello world  </description>
    </item>
    
    <item>
      <title>Docker容器间通信</title>
      <link>http://imroc.io/post/docker/docker-network-communication/</link>
      <pubDate>Wed, 06 Sep 2017 16:35:18 +0800</pubDate>
      <author>roc@imroc.io (roc)</author>
      <guid>http://imroc.io/post/docker/docker-network-communication/</guid>
      <description> 容器每次启动时会分配个一个IP地址，这个IP地址只在宿主主机内部有用，其它主机上的程序无法访问此IP
 一台机器上的docker容器之间默认是可以通过分配的IP进行通信的，可以通过启动参数 -icc=false —iptables=true 来关闭互通，严格隔离以提高安全性
 虽然每次启动分配的IP可能会变，但启动时加类似 —link redis:db 这样的参数给容器起别名，可以起到DNS作用，原理是在 /etc/hosts 里面映射IP到别名，这样你的程序和其他容器通信就可以不用管IP，用别名，IP变但它不会变
 link只支持单主机，跨主机link最早的方案是Ambassador(docker远程代理)，每台主机启动一个Ambassador容器负责对主机上其它容器的网络转发(socket proxy)，后演变成 github.com/gliderlabs/connectable
 手动处理容器间通信很麻烦，一般用编排工具：kubernetes、swarm&amp;hellip;&amp;hellip;
  </description>
    </item>
    
  </channel>
</rss>